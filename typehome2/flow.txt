typescript 기반의 리액트 앱 작성하기 
npx create-react-app  typehome --template typescript
cd typehome
npm install bootstrap
npm install axios 
npm install react-router-dom 

useReducer : 함수를 외부로 빼내기 위한것, 아무데서나 사용가능하도록 
useContext : context - 어플리케이션 그 자체로 
                 전역객체를 만들고자 할때 사용한다. 많이는 아니지만 필요할 경우가 있다 
                 로그온 아이디나 이름을 저장해두고 다르곳에서 사용한다던지 
                 F5 버튼 누르면 없어짐 , 세션이나 쿠키나 로컬스토리지 
                세션에 서버에 저장되는객체, 모든 클라이언트마다 만들어짐 
                          로그온정보나 장바구니 정보 
                쿠키는 클라이언트에게 저장되는 객체,모든 클라이언트마다 만들어짐 
                          로그온정보나 장바구니 정보 . 보안문제가 발생해서 10년넘게 
                          사용안함 
                로컬스토리지 - html5에서 추가, 쿠키보다 보안 강화, 인터넷 끊어져도 
                         사용가능 
  
useContext  기본 사용법 
                1. createContext로 컨텍스트개체를 생성한다. 
                   값이나 함수등을 전달을 해야 한다 
                   context.Provider로 해야 한다 value속성으로 
                  value속성에 값 전달, json등을 통해서 값전달을 가능한데 
                  let MyContext = createContext();
                  MyContext.Provider가 자체적으로 만들어진다. 
                  <MyContext.Provider value={값이나 JSON객체등}>
                       .... 동일 컨텍스트를 소유할 컴포넌트들 
                  </MyContext.Provider>
                   이럴경우에는 value의 값 변경불가 
                   
                2. Provider를 커스터마이징 한다   
                const AppProvider = ({children}:{children:any})=>{
                 // 필요한 state나 함수들을 저장한다 
                    return(
                        <MyContext.Provider value={{state, dispatch}}>
                          {children}
                        </MyContext.Provider>
                   );
               }   
                3. F5를 누르면 컨텍스트에 저장된 값이 없어진다. (세션, 쿠키, 로컬스토리지)등에 
                  저장을 해야 한다 
                  저장시 : localStorage.setItem(key, JSON.stringify(state)); 
                  가져올때 :let result = JSON.parse(localStorage.getItem(key));

                 
		2번 항목에서 reducer를 사용함 
                초기상태와 처리함수들을 묶어서 처리함 
		

               const initalState:StateType={userid:"", username:"", isLogon:false}

              //Reducer 따로 생성 
function LogonReducer(state:StateType, action:LogonAction):StateType
{
    switch(action.type)
    {
        case "LOGON":
            {
                //jsonplaceholder에 /user
                //fetch나 axios써서 갖고 데이터 갖고 와서 로그온 작업 제대로 
                //userid 가져와서 axios 를 이용해서 api서버와 통신후 
                //가져온 값을 넣는다 return 시점이 then 안에서 하거나 
                //async, await 를 사용해야 한다 
                let newState =  {...state, userid:action.value.userid, 
                    username:"홍길동", 
                    isLogon:true};
                //F5 누르면 날아감 
                saveStateToLocalStorage("appState", newState);
                return newState;
            }
        case "LOGOUT":
            {
                let newState =  {...state, userid:"", username:"", 
                    isLogon:false};
                saveStateToLocalStorage("appState", newState);
                return newState;
            }
        case "RESET":
            return initalState;
        default:
            throw new Error("알수없는 액션입니다.");     
    }
}


      프로바이더 내에서    
      const [state, dispatch] = useReducer(LogonReducer, initalState); 
               state :항상 최신의 상태로 유지된다.(새로 state가 바뀌어도 저장하고 있다) 
               dispatch -> reducer를 호출해야 한다. 
      useReducer( LogonReducer , 초기상태)  
      

      사용시에는 
      let myContext = useContext(MyContext); 
      myContext.state
      myContext.dispatch 가 있다 dispatch 
      
      LogonReducer 함수 주소를  dispatch가 가지고 있다 
      context.dispatch( {type:"LOGON", value:{userid:userid,  username:"", isLogon:true}});


       https://jsonplaceholder.typicode.com/users

      logon  창에서 userid를 입력한다.  ==> dispatch 를 통해서 LogonReducer로 전달 
      axios.get(  "https://jsonplaceholder.typicode.com/users?userid=1"


useEffect(() => {
  const subscription = props.source.subscribe();
  return () => {
    // Clean up the subscription
    subscription.unsubscribe();
  };
});

훅 -> 그냥 사용법 , 가로채서, 정상적 흐름을 가로채서 우리 코드를 넣는다 
class CounterClass extends Component {
  constructor(props) {  //생성자의 매개변수로 props 부모 컴포넌트로부터 받아온다 ,
    super(props); //부모생성자 호출
    this.state = {  //state요소에 값을 저장한다 
      count: 0,
    };
    this.increment = this.increment.bind(this);
  }

  increment() {
    this.setState({ count: this.state.count + 1 });
  }
	
  componentDidMount() {
    document.title = "You clicked " + this.state.count + " times";
  }

  componentDidUpdate() {
    document.title = "You clicked " + this.state.count + " times";
  }

  componentDidUnmount() {
    document.title = "You clicked " + this.state.count + " times";
  }

  useEffect : componentDidMount, componentDidUpdate,componentDidUnmount

  useEffect( ()=>{}, [] ); //Mount될때랑 Unmount될때 2번 호출된다. 
  네트워크 송수신시 두번 호출되는거 막는다 .
 세션아 컨텍스트등 쓰고 있는데 컴포넌트가 동작을 하고 unmount 되서 나갔는데 
 백그라운드에서 일하고 있는 애들이 있는데 
 
  useEffect( ()=>{
		................  //mount 때 호출되고 
	return ()=>{ //cleanup함수 : unmount 될때 반드시 뭔가 할일이 필요할때 
 }, [변수] );
 안써도 되는 이유는 모던스크립트 메모리관리를 알아서 

1. 게시판 목록 -> 2.게시판수정 3.데이타삭제 4.추가 

1 제목1       홍길동              [수정][삭제] 

BoardList에서 컴포넌트가 안바뀌고 데이터를 axios를 통해서 삭제를 시켜 
useEffect -> 다시 호출하고 싶다. (컴포넌트 자체는 그대로인데 디비에 가서 데이터 삭제시켰음
            ->loading state저장해놓고 이변수값을 

useEffect( ()=>{
          배열 주소가 바뀐다. 
		................  //mount 때 호출되고 
	return ()=>{ //cleanup함수 : unmount 될때 반드시 뭔가 할일이 필요할때 
 }, [loading] );

다른 함수내애서  loading변수값을 바꾸면 알아서 useEffect 가 호출되면서 게시목록을 다시 불러온다
window.location.reload가 있음 F5 눌렀을때 호출된다. 가급적 사용금지임 
그래서 컴포넌트 바뀌치기를 할때 useNavigate  객체를 만든다. - 스택구조  
navigate(url, {state});  //다른컴포넌트한테 필요한 정보 전달이 가능하다 
받는쪽에서는 useLocation 을 사용하면 navigate가 전달한 정보(JSON)으로 보내면 
let location = useLocation();
//JSON해체작업 
const {value1, value2} = location; 

1. useState 
2. useEffect
3. useNavigate
4. useLocation 
5. useMemo -->     재귀호출 : 개발자가 코딩을 쉽게하기 위한거 , 스택공간을 미친듯이 사용한다 
                         A()
                             A()
                                  A()
                                      ...........
 
                         속도도 엄청 느리다.  함수를 때마다 호출하지 말고 한번호출됬던 함수의 
                        결과값을 메모리에 저장해놓고 다른데서 다시 호출할때 있던값 던져준다 
                        (캐쉬)

6. useReducer - 상태값과 함수를 분리하고자 한다 . => redux라이브러리를 주로 사용한다 
                   -  상태값변경만 해야 한다. 상태변경외에는 아무것도 하면 안된다. 
                   -  함수는 하나의 일에만 집중하자. 
                   - axios나 fetch나(Ajax기술) 이런거 여기서 쓰지말고 별도로 미들웨어 
                    를 만들어 나가든가 아니면  redux라이브러리를 사용하면 된다. 
   reducer => (현재상태, 다음에해야할액션) {
              현재상태에 다음에해야할액션을 처리해서 새로운 상태를 반환한다  
   }
   이 개념을 확장한것이 useReducer이다. 
   1)초기상태
   2)Reducer로 사용할 함수가 필요 

    3) Reducer를 Context에 저장해서 다른 객체들한테 전달할수도 있다  
function LogonReducer(state, action)
{
    switch(action.type)  //action을 요청하는 그럼 LogonReducer , LogoutReducer를 만들려면 
    {
        case "LOGON":  //type속성 , value 를 넣어서 값을 전달할 수 있다 
            {
                let newState =  {...state, userid:action.value.userid, 
                    username:action.value.username, isLogon:true}; //새로운 상태 만들고 
                console.log( newState );
                saveStateToLocalStorage("appState", newState); //로컬스토리지 사용정보 끼워듬
                return newState;     //반환하고 
            }
        case "LOGOUT":
            {
                let newState =  {...state, userid:"", username:"", isLogon:false};
                saveStateToLocalStorage("appState", newState);
                return newState;
            }
        case "RESET":
            return initalState;
        default:
            throw new Error("알수없는 액션입니다.");     
    }
}

7. useContext -전역적으로 값을 보관한다. 근데 이게 좋을까?
   1) 컨텐스트 객체를 생성한다 
   2) 자동적으로 Provider 가 만들어진다.  Provider를 통해서  value속성에 값도 저장
       가능하고 JSON객체 저장 가능 , 변수도 함수도  JSON 객체에 저장할 수 있다. 
  3) 값 업데이트 수단은 별도로 없다. 
    실시간으로 컨텍스트 값이 바뀌길 원하면 커스터마이징을 한다. 
    <MyContext.Provider value="">
           ...컴포넌트 : 그래야 컨텍스트를 공유할 수 있다 
    </MyContext.Provider />
    커스터마이징할때 함수의 매개변수{children} <- 컴포넌트들이 전달된다. 
    유지해야할 상태와 업데이트 함수가 필요하면 만들어서 value에 전달한다. 

  4)사용할때는 
     let context = useContext(MyContext); 

userId --->  Album 소유   -----> 사진들을 소유(Photo)
                1 다음카페     -----> 1번 사진들 쭈욱 
                2 트위터       ----->  2번 사진들 쭈욱 
                3 다운로드     -----> 3번 사진들 쭈욱 

이용자리스트 전부  
https://jsonplaceholder.typicode.com/users

특정 사용자 정보 가져오기   <=== 로그온       : Logon.tsx  --> useNavigate
https://jsonplaceholder.typicode.com/users?id=1

https://jsonplaceholder.typicode.com/album

특정사용자의 경우에는   <== 앨범가져오기   : AlbumList --> useNavigate 서로간에 컨텍스트 스위치상황
https://jsonplaceholder.typicode.com/album?userId=1                           useNavigate와 useLocation
Album   :                                                                                     적절하게 사용하면 된다.
{
        "userId": 1,     //사용자아이디              
        "id": 1,   //앨범식별값                
        "title": "quidem molestiae enim"  //앨범제목
  },

전부가져온다 
https://jsonplaceholder.typicode.com/photos  : photoList  --> useNavigate

특정앨범의 경우에 해당하는 포터만 가져온다 
https://jsonplaceholder.typicode.com/photos?albumId=1

Photos {
{
        "albumId": 1, //앨범아이디 
        "id": 1, //자기 구분 식별값 
        "title": "accusamus beatae ad facilis cum similique qui sunt", //이미지 제목
        "url": "https://via.placeholder.com/600/92c952", //이미지 url
        "thumbnailUrl": "https://via.placeholder.com/150/92c952" //이미지 섬네알 url 
  },


users                             
 {
        "id": 1,
        "name": "Leanne Graham",
        "username": "Bret",
        "email": "Sincere@april.biz",
        "address": {
            "street": "Kulas Light",
            "suite": "Apt. 556",
            "city": "Gwenborough",
            "zipcode": "92998-3874",
            "geo": {
                "lat": "-37.3159",
                "lng": "81.1496"
            }
        },
        "phone": "1-770-736-8031 x56442",
        "website": "hildegard.org",
        "company": {
            "name": "Romaguera-Crona",
            "catchPhrase": "Multi-layered client-server neural-net",
            "bs": "harness real-time e-markets"
        }
    },
















	
